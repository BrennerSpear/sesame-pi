# App Flow Document

## Onboarding and Sign-In/Sign-Up

The experience on this project begins even before the Raspberry Pi starts processing any audio. When a brand-new user engages with the system, they might first interact with a companion portal on a website. This portal is where users perform sign-in or sign-up activities. Here, the user can log in via email or social login to retrieve a JWT token. Once authenticated on the portal, the token is then made available to the Raspberry Pi system. Although the Raspberry Pi itself does not offer a traditional account management interface, it relies on the companion service for secure token handling. The portal also provides options for password recovery and token regeneration if the credentials are lost or need to be updated. This initial authentication step ensures that when the Raspberry Pi starts its operation, it can access the necessary credentials for communication with the third-party service.

## Main Dashboard or Home Page

After the Raspberry Pi finishes initializing its hardware components and establishing necessary configurations, it enters an idle state, which can be considered its main dashboard. In this state, the device awaits user interaction. There is no graphical user interface typical of web applications; instead, the main screen is the functional state of the device where the system is continuously monitoring the status of its WebSocket connection, the state of the microphone and speakers, and the physical button input. An LED indicator or audible tone may be used to signal that the system is ready and awaiting a session start. The flow from this idle state to active sessions is seamless and occurs once the physical button is pressed.

## Detailed Feature Flows and Page Transitions

On powering up, the system first initializes all required hardware components. During the initialization stage, the script configures the microphone for audio capture, sets up the speakers for audio output, and configures a chosen GPIO pin (for example, GPIO 17 on Pin 11) for a physical button. Part of this initialization involves setting up software debouncing to ensure reliable button interactions. Almost concurrently, the system establishes a persistent WebSocket connection to the third-party server at the provided URL. It is during this phase that initial parameters such as sample rate (16 kHz) and bit depth (16 bits) are set up to guarantee high-quality audio processing with low latency.

Once the hardware and WebSocket connection are in place, the user initiates a session by pressing the physical button. A short button press signals the start session command, and the system reads any pre-fetched JWT token from the companion website. With authentication credentials in place, the Raspberry Pi informs the server that a new session is starting. At this point, the system begins capturing audio from the microphone. Code routines immediately start streaming the captured voice data through the WebSocket connection in real time to the server. As soon as the server processes the information and sends a response, the system plays the incoming audio through the speakers. Thanks to full-duplex audio processing, both the streaming of the microphone input and the processing of server response audio occur concurrently, ensuring that the conversation appears natural with latency maintained below 200 ms.

The transition from session activation to active full-duplex operation is smooth. There is no interruption in user experience because, while the microphone continues to capture voice data, the speakers simultaneously play the audio data arriving from the server. The script is programmed to handle periodic or special messages such as a server 'ping' message, keeping the connection alive and operational. When the user wants to end the session, a safeguard mechanism is triggered. Instead of a quick button press, a press-and-hold action of about 2 seconds is required to distinguish an intentional session termination from an accidental press. Once this prolonged press is detected, the system logs the event, stops the audio capture, and gracefully initiates disconnection from the WebSocket server. The session termination sequence might be supported by an audible or visual confirmation, ensuring the user is aware that the shutdown process has begun.

## Settings and Account Management

Since the primary interaction occurs with the Raspberry Pi and the companion website, account and session settings are handled in a distributed manner. The companion website functions as the management platform for user credentials and JWT token handling. Users can update their preferences on the portal, which in turn affects how the Raspberry Pi interfaces with the server. On the device side, physical settings such as microphone sensitivity, speaker volume, and GPIO pin configuration are defined in the initial script configuration. While there is no dedicated on-device settings menu, any adjustments to audio processing parameters, like sample rate or bit depth, are managed through configuration files or software settings. These settings are loaded during initialization and automatically applied. Once the necessary configurations are set, the system returns to its idle state, ready for session activation.

## Error States and Alternate Paths

The system has been designed with robust error handling in mind. In the event of a network interruption causing the WebSocket connection to drop, the script automatically triggers reconnection attempts using an exponential backoff strategy. During this error state, logs are maintained locally that record details including timestamps, error messages, and the number of reconnection attempts. If reconnection is unsuccessful after a set number of attempts, the system provides an audio or visual signal alerting the user of the disconnection. Additionally, if the button is pressed by accident during an active session, the short press is ignored for session termination; only a sustained press for 2 seconds is valid for ending the session. In instances where the microphone or speaker is disconnected, error messages are logged and the system may attempt to reset the audio drivers. In every error scenario, the system includes a fallback mechanism whereby once the problematic component is reset, the system attempts to re-establish a normal operating flow by reconnecting the WebSocket and reinitializing the audio streams as necessary.

## Conclusion and Overall App Journey

Throughout the lifecycle of the device, the userâ€™s journey flows from initial authentication on the companion portal to powering on the Raspberry Pi and entering an idle state that signals readiness. When the user initiates an interaction by pressing the physical button, the system reads the saved JWT token, establishes a session via the WebSocket connection, and enters a full-duplex audio mode where voice input is captured and server responses played back concurrently. The session continues seamlessly until a deliberate, press-and-hold action on the button is performed, ensuring that accidental presses do not interrupt the session. Robust error handling ensures that network interruptions, hardware disconnections, or other errors are managed gracefully with clear signals to the user, and the system is capable of automatically recovering from such events. In summary, the overall journey provides an intuitive, secure, and responsive voice interaction experience, seamlessly linking the physical hardware of the Raspberry Pi with the remote AI processing capabilities of the Sesame AI demo service.
